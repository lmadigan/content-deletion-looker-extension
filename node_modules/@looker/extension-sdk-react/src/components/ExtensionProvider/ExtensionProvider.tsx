/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Looker Data Sciences, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

import React, { useState, useRef } from 'react'
import { MemoryRouter } from 'react-router-dom'
import { LookerExtensionSDK, connectExtensionHost, ExtensionHostApi } from '@looker/extension-sdk'
import { LookerSDK } from '@looker/sdk/dist/sdk/methods'
import { ExtensionProviderProps, ExtensionContextData } from './types'
import { RouteChangeListener } from './components/RouteChangeListener'

export { LookerSDK }

/**
 * React context provider for extension API and SDK
 */
export const ExtensionContext = React.createContext<ExtensionContextData>(
  undefined as any // no one will ever see this undefined!
)

const initializingMessage = 'Establishing communication with Looker host'
const initializeFailedMessage = 'Failed to establish communication with Looker host'

/**
 * The ExtensionContextData interface requires that there is an ExtensionHostApi.
 * Now that error handling has been added, the ExtensionHostApi is no longer
 * always available. Provide a dummy implementation.
 */
const createTempExtensionHostApi = (errorMessage: string): ExtensionHostApi => ({
  invokeCoreSdkByName: () => {
    throw new Error(errorMessage)
  },
  invokeCoreSdkByPath: () => {
    throw new Error(errorMessage)
  },
  verifyHostConnection: () => {
    throw new Error(errorMessage)
  },
  handleNotification: () => {},
  clientRouteChanged: () => {},
  updateTitle: () => {},
  updateLocation: () => {},
  openBrowserWindow: () => {},
  closeHostPopovers: () => {}
})

/**
 * ExtensionProvider component. Provides access to the extension API and SDK (use
 * ExtensionContext) and react routing services.
 */
export const ExtensionProvider: React.FC<ExtensionProviderProps> = ({
  onPathnameChange,
  hostTracksRoute = true,
  loadingComponent,
  requiredLookerVersion,
  children
}) => {
  const [initialRoute, setInitialRoute] = useState()
  const hostInitializedTimerId = useRef(0)
  const [initializing, setInitializing] = useState(true)
  const [extensionData, setExtensionData] = React.useState<ExtensionContextData>({
    extensionSDK: createTempExtensionHostApi(initializingMessage),
    coreSDK: {} as LookerSDK
  })

  const initialized = (errorMessage?: string) => {
    window.clearTimeout(hostInitializedTimerId.current)
    setInitializing(false)
    if (errorMessage) {
      setExtensionData((previousState: ExtensionContextData) => {
        return {
          ...previousState,
          initializeError: errorMessage
        }
      })
    }
  }

  React.useEffect(() => {
    hostInitializedTimerId.current = window.setTimeout(() => {
      console.error('Failed to establish host connection')
      setInitializing(false)
      setExtensionData((previousState: ExtensionContextData) => {
        return {
          ...previousState,
          initializeError: initializeFailedMessage,
          extensionSDK: createTempExtensionHostApi(initializeFailedMessage)
        }
      })
    }, 10000)
    connectExtensionHost({
      initializedCallback: initialized,
      setInitialRoute: hostTracksRoute ? setInitialRoute : undefined,
      requiredLookerVersion
    })
      .then((extensionHost) => {
        setExtensionData((previousState: ExtensionContextData) => {
          return {
            ...previousState,
            extensionSDK: extensionHost,
            coreSDK: LookerExtensionSDK.createClient(extensionHost)
          }
        })
      })
      .catch((error) => {
        console.error(error)
        window.clearTimeout(hostInitializedTimerId.current)
        setInitializing(false)
        setExtensionData((previousState: ExtensionContextData) => {
          return {
            ...previousState,
            initializeError: error.message ? error.message : initializeFailedMessage,
            extensionSDK: createTempExtensionHostApi(initializeFailedMessage)
          }
        })
      })
  }, [])

  React.useEffect(() => {
    const onBodyMousedown = () => {
      if (extensionData && extensionData.extensionSDK) {
        extensionData.extensionSDK.closeHostPopovers()
      }
    }
    let body: HTMLBodyElement | undefined | null
    if (!initializing) {
      body = document.querySelector('body')
      if (body) {
        body.addEventListener('mousedown', onBodyMousedown)
      }
    }
    return () => {
      if (body) {
        body.removeEventListener('mousedown', onBodyMousedown)
      }
    }
  }, [initializing])

  const initialEntries: string[] | undefined = initialRoute ? [initialRoute] : undefined

  return (
    <>
      {initializing && loadingComponent}
      {hostTracksRoute && !initializing && (
        <MemoryRouter initialEntries={initialEntries}>
          <RouteChangeListener onPathnameChange={onPathnameChange} extensionHost={extensionData!.extensionSDK} />
          <ExtensionContext.Provider value={extensionData!}>{children}</ExtensionContext.Provider>
        </MemoryRouter>
      )}
      {!hostTracksRoute && !initializing && (
        <ExtensionContext.Provider value={extensionData!}>{children}</ExtensionContext.Provider>
      )}
    </>
  )
}

/**
 * @deprecated use ExtensionProvider instead
 */
export const ExportWrapper = ExtensionProvider
