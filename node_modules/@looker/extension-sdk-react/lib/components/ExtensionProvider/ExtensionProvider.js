"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "LookerSDK", {
  enumerable: true,
  get: function get() {
    return _methods.LookerSDK;
  }
});
exports.ExportWrapper = exports.ExtensionProvider = exports.ExtensionContext = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _reactRouterDom = require("react-router-dom");

var _extensionSdk = require("@looker/extension-sdk");

var _methods = require("@looker/sdk/dist/sdk/methods");

var _RouteChangeListener = require("./components/RouteChangeListener");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * React context provider for extension API and SDK
 */
var ExtensionContext = _react["default"].createContext(undefined // no one will ever see this undefined!
);

exports.ExtensionContext = ExtensionContext;
var initializingMessage = 'Establishing communication with Looker host';
var initializeFailedMessage = 'Failed to establish communication with Looker host';
/**
 * The ExtensionContextData interface requires that there is an ExtensionHostApi.
 * Now that error handling has been added, the ExtensionHostApi is no longer
 * always available. Provide a dummy implementation.
 */

var createTempExtensionHostApi = function createTempExtensionHostApi(errorMessage) {
  return {
    invokeCoreSdkByName: function invokeCoreSdkByName() {
      throw new Error(errorMessage);
    },
    invokeCoreSdkByPath: function invokeCoreSdkByPath() {
      throw new Error(errorMessage);
    },
    verifyHostConnection: function verifyHostConnection() {
      throw new Error(errorMessage);
    },
    handleNotification: function handleNotification() {},
    clientRouteChanged: function clientRouteChanged() {},
    updateTitle: function updateTitle() {},
    updateLocation: function updateLocation() {},
    openBrowserWindow: function openBrowserWindow() {},
    closeHostPopovers: function closeHostPopovers() {}
  };
};
/**
 * ExtensionProvider component. Provides access to the extension API and SDK (use
 * ExtensionContext) and react routing services.
 */


var ExtensionProvider = function ExtensionProvider(_ref) {
  var onPathnameChange = _ref.onPathnameChange,
      _ref$hostTracksRoute = _ref.hostTracksRoute,
      hostTracksRoute = _ref$hostTracksRoute === void 0 ? true : _ref$hostTracksRoute,
      loadingComponent = _ref.loadingComponent,
      requiredLookerVersion = _ref.requiredLookerVersion,
      children = _ref.children;

  var _useState = (0, _react.useState)(),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      initialRoute = _useState2[0],
      setInitialRoute = _useState2[1];

  var hostInitializedTimerId = (0, _react.useRef)(0);

  var _useState3 = (0, _react.useState)(true),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      initializing = _useState4[0],
      setInitializing = _useState4[1];

  var _React$useState = _react["default"].useState({
    extensionSDK: createTempExtensionHostApi(initializingMessage),
    coreSDK: {}
  }),
      _React$useState2 = (0, _slicedToArray2["default"])(_React$useState, 2),
      extensionData = _React$useState2[0],
      setExtensionData = _React$useState2[1];

  var initialized = function initialized(errorMessage) {
    window.clearTimeout(hostInitializedTimerId.current);
    setInitializing(false);

    if (errorMessage) {
      setExtensionData(function (previousState) {
        return _objectSpread({}, previousState, {
          initializeError: errorMessage
        });
      });
    }
  };

  _react["default"].useEffect(function () {
    hostInitializedTimerId.current = window.setTimeout(function () {
      console.error('Failed to establish host connection');
      setInitializing(false);
      setExtensionData(function (previousState) {
        return _objectSpread({}, previousState, {
          initializeError: initializeFailedMessage,
          extensionSDK: createTempExtensionHostApi(initializeFailedMessage)
        });
      });
    }, 10000);
    (0, _extensionSdk.connectExtensionHost)({
      initializedCallback: initialized,
      setInitialRoute: hostTracksRoute ? setInitialRoute : undefined,
      requiredLookerVersion: requiredLookerVersion
    }).then(function (extensionHost) {
      setExtensionData(function (previousState) {
        return _objectSpread({}, previousState, {
          extensionSDK: extensionHost,
          coreSDK: _extensionSdk.LookerExtensionSDK.createClient(extensionHost)
        });
      });
    })["catch"](function (error) {
      console.error(error);
      window.clearTimeout(hostInitializedTimerId.current);
      setInitializing(false);
      setExtensionData(function (previousState) {
        return _objectSpread({}, previousState, {
          initializeError: error.message ? error.message : initializeFailedMessage,
          extensionSDK: createTempExtensionHostApi(initializeFailedMessage)
        });
      });
    });
  }, []);

  _react["default"].useEffect(function () {
    var onBodyMousedown = function onBodyMousedown() {
      if (extensionData && extensionData.extensionSDK) {
        extensionData.extensionSDK.closeHostPopovers();
      }
    };

    var body;

    if (!initializing) {
      body = document.querySelector('body');

      if (body) {
        body.addEventListener('mousedown', onBodyMousedown);
      }
    }

    return function () {
      if (body) {
        body.removeEventListener('mousedown', onBodyMousedown);
      }
    };
  }, [initializing]);

  var initialEntries = initialRoute ? [initialRoute] : undefined;
  return _react["default"].createElement(_react["default"].Fragment, null, initializing && loadingComponent, hostTracksRoute && !initializing && _react["default"].createElement(_reactRouterDom.MemoryRouter, {
    initialEntries: initialEntries
  }, _react["default"].createElement(_RouteChangeListener.RouteChangeListener, {
    onPathnameChange: onPathnameChange,
    extensionHost: extensionData.extensionSDK
  }), _react["default"].createElement(ExtensionContext.Provider, {
    value: extensionData
  }, children)), !hostTracksRoute && !initializing && _react["default"].createElement(ExtensionContext.Provider, {
    value: extensionData
  }, children));
};
/**
 * @deprecated use ExtensionProvider instead
 */


exports.ExtensionProvider = ExtensionProvider;
var ExportWrapper = ExtensionProvider;
exports.ExportWrapper = ExportWrapper;
//# sourceMappingURL=ExtensionProvider.js.map