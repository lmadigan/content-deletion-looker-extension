import * as d3color from 'd3-color';
import * as d3hsv from 'd3-hsv';
import { toPercent } from './math_utils';
import { namedColors } from './named_colors';
export var ColorFormat;
(function (ColorFormat) {
    ColorFormat[ColorFormat["NAME"] = 0] = "NAME";
    ColorFormat[ColorFormat["HEX3"] = 1] = "HEX3";
    ColorFormat[ColorFormat["HEX6"] = 2] = "HEX6";
    ColorFormat[ColorFormat["RGBI"] = 3] = "RGBI";
    ColorFormat[ColorFormat["RGBIA"] = 4] = "RGBIA";
    ColorFormat[ColorFormat["RGBP"] = 5] = "RGBP";
    ColorFormat[ColorFormat["RGBPA"] = 6] = "RGBPA";
    ColorFormat[ColorFormat["HSL"] = 7] = "HSL";
    ColorFormat[ColorFormat["HSLA"] = 8] = "HSLA";
    ColorFormat[ColorFormat["TRANSPARENT"] = 9] = "TRANSPARENT";
    ColorFormat[ColorFormat["BAD"] = 10] = "BAD";
})(ColorFormat || (ColorFormat = {}));
const RGB_MAX_VALUE = 255;
const recognize = (format) => {
    const reI = '\\s*([+-]?\\d+)\\s*';
    const reN = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*';
    const reP = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*';
    const reHex3 = /^#([0-9a-f]{3})$/;
    const reHex6 = /^#([0-9a-f]{6})$/;
    const reRgbInteger = new RegExp('^rgb\\(' + [reI, reI, reI] + '\\)$');
    const reRgbPercent = new RegExp('^rgb\\(' + [reP, reP, reP] + '\\)$');
    const reRgbaInteger = new RegExp('^rgba\\(' + [reI, reI, reI, reN] + '\\)$');
    const reRgbaPercent = new RegExp('^rgba\\(' + [reP, reP, reP, reN] + '\\)$');
    const reRgbaPercent2 = new RegExp('^rgba\\(' + [reP, reP, reP, reP] + '\\)$');
    const reHslPercent = new RegExp('^hsl\\(' + [reN, reP, reP] + '\\)$');
    const reHslaPercent = new RegExp('^hsla\\(' + [reN, reP, reP, reN] + '\\)$');
    format = String(format)
        .trim()
        .toLowerCase();
    return reHex3.exec(format)
        ? ColorFormat.HEX3
        : reHex6.exec(format)
            ? ColorFormat.HEX6
            : reRgbInteger.exec(format)
                ? ColorFormat.RGBI
                : reRgbPercent.exec(format)
                    ? ColorFormat.RGBP
                    : reRgbaInteger.exec(format)
                        ? ColorFormat.RGBIA
                        : reRgbaPercent.exec(format)
                            ? ColorFormat.RGBPA
                            : reRgbaPercent2.exec(format)
                                ? ColorFormat.RGBPA
                                : reHslPercent.exec(format)
                                    ? ColorFormat.HSL
                                    : reHslaPercent.exec(format)
                                        ? ColorFormat.HSLA
                                        : Object.prototype.hasOwnProperty.call(namedColors, format)
                                            ? ColorFormat.NAME
                                            : format === 'transparent'
                                                ? ColorFormat.TRANSPARENT
                                                : ColorFormat.BAD;
};
export const getFormat = (value) => ColorFormat[recognize(value)];
export const getOpacity = (color) => {
    if (color instanceof d3color.cubehelix ||
        color instanceof d3color.hcl ||
        color instanceof d3color.hsl ||
        color instanceof d3color.rgb ||
        color instanceof d3color.lab) {
        return color.opacity;
    }
    return 1;
};
const namedColorLookup = (color) => {
    const hex = color.hex().replace(/^#/, '');
    const lookup = parseInt(hex, 16);
    const namedColorsFlipped = new Map(Object.entries(namedColors).map(([k, v]) => [v, k]));
    return namedColorsFlipped.get(lookup);
};
export const toColorName = (color, opacity = null) => {
    const opacityUse = opacity || getOpacity(color);
    const name = namedColorLookup(color);
    if (name)
        return name;
    if (opacityUse !== 1)
        return d3color.rgb(color).toString();
    return color.hex();
};
export const toRGBIString = (color, opacity = null, useAlpha = false) => {
    const opacityUse = opacity || getOpacity(color);
    const rgb = color.rgb();
    const r = Math.round(rgb.r);
    const g = Math.round(rgb.g);
    const b = Math.round(rgb.b);
    if (useAlpha || opacityUse !== 1) {
        return `rgba(${r}, ${g}, ${b}, ${opacityUse})`;
    }
    return `rgb(${r}, ${g}, ${b})`;
};
export const toRGBPString = (color, opacity = null, useAlpha = false) => {
    const opacityUse = opacity || getOpacity(color);
    const rgb = color.rgb();
    const r = toPercent(rgb.r, RGB_MAX_VALUE);
    const g = toPercent(rgb.g, RGB_MAX_VALUE);
    const b = toPercent(rgb.b, RGB_MAX_VALUE);
    if (useAlpha || opacityUse !== 1) {
        return `rgba(${r}%, ${g}%, ${b}%, ${opacityUse})`;
    }
    return `rgb(${r}%, ${g}%, ${b}%)`;
};
export const toHSLString = (color, opacity = null, useAlpha = false) => {
    const opacityUse = opacity || getOpacity(color);
    const hsl = d3color.hsl(color);
    const h = isNaN(hsl.h) ? 0 : hsl.h;
    const s = isNaN(hsl.s) ? 0 : Math.round(hsl.s * 100);
    const l = isNaN(hsl.l) ? 100 : Math.round(hsl.l * 100);
    if (useAlpha || opacityUse !== 1) {
        return `hsla(${h}, ${s}%, ${l}%, ${opacityUse})`;
    }
    return `hsl(${h}, ${s}%, ${l}%)`;
};
export const toFormattedColorString = (value, format = null) => {
    const color = d3color.color(value);
    if (!color)
        return '';
    if (!color.displayable)
        return '';
    if (format === null)
        format = recognize(value);
    const opacity = getOpacity(color);
    switch (format) {
        case ColorFormat.NAME:
        case ColorFormat.TRANSPARENT:
            return toColorName(color);
        case ColorFormat.HEX3:
        case ColorFormat.HEX6:
            if (opacity === 1)
                return color.hex();
            return color.rgb().toString();
        case ColorFormat.RGBI:
            return color.rgb().toString();
        case ColorFormat.RGBIA:
            return toRGBIString(color, opacity, true);
        case ColorFormat.RGBP:
            return toRGBPString(color, opacity);
        case ColorFormat.RGBPA:
            return toRGBPString(color, opacity, true);
        case ColorFormat.HSL:
            return toHSLString(color, opacity);
        case ColorFormat.HSLA:
            return toHSLString(color, opacity, true);
        default:
            return color.toString();
    }
};
export const toHSV = (value) => {
    const color = d3color.color(value);
    if (!color)
        return null;
    return d3hsv.hsv(color);
};
export const hsvToColorString = (hsvColor, format = null) => toFormattedColorString(hsvColor.rgb().toString(), format);
export const hsv2hex = (color) => d3hsv.hsv(color.h, color.s, color.v).hex();
export const str2simpleHsv = (color) => {
    const hsvColor = d3hsv.hsv(color);
    const simpleHSV = { h: hsvColor.h, s: hsvColor.s, v: hsvColor.v };
    return simpleHSV;
};
export const simpleHSVtoRGB = (color) => d3hsv.hsv(color.h, color.s, color.v).rgb();
export const simpleHSVtoFormattedColorString = (color, colorFormat) => {
    const rgbColor = simpleHSVtoRGB(color);
    switch (colorFormat) {
        case 'NAME':
            return toColorName(rgbColor);
        case 'RGBI':
        case 'RGBIA':
            return toRGBIString(rgbColor);
        case 'RGBP':
        case 'RGBPA':
            return toRGBPString(rgbColor);
        case 'HSL':
        case 'HSLA':
            return toHSLString(rgbColor);
        case 'HEX3':
        case 'HEX6':
        default:
            return rgbColor.hex();
    }
};
//# sourceMappingURL=color_format_utils.js.map