import React, { Component } from 'react';
import styled from 'styled-components';
import { hsv } from 'd3-hsv';
import { canvasMargin, canvasRadius, clearCanvas, drawColorWheelIntoCanvasImage, eventCartesianPosition, } from './canvas_utils';
import { cartesian2hsv, generateColorWheel, hsv2cartesian, } from './color_wheel_utils';
import { diameter, limitByRadius, translateDiagonal, } from './math_utils';
export class ColorWheel extends Component {
    constructor() {
        super(...arguments);
        this.isMouseDragging = false;
        this.setColorWheelCanvasRef = (element) => {
            this.colorWheelCanvas = element;
        };
        this.setValueCanvasRef = (element) => {
            this.valueCanvas = element;
        };
        this.setCompositeCanvasRef = (element) => {
            this.compositeCanvas = element;
        };
        this.setMarkerCanvasRef = (element) => {
            this.markerCanvas = element;
        };
        this.mouseDown = (event) => {
            this.setMouseDragging(true);
            const canvasCartesian = eventCartesianPosition(this.colorWheelCanvas, event);
            const position = limitByRadius(translateDiagonal(-canvasMargin, canvasCartesian), this.radius);
            this.updateColor(position, this.props.onColorChange);
        };
        this.mouseMove = (event) => {
            if (this.isMouseDragging) {
                const canvasCartesian = eventCartesianPosition(this.colorWheelCanvas, event);
                const position = limitByRadius(translateDiagonal(-canvasMargin, canvasCartesian), this.radius);
                this.updateColor(position, this.props.onColorChange);
            }
        };
        this.setMouseDragging = (isDragging) => {
            this.isMouseDragging = isDragging;
        };
        this.drawValueLayer = () => {
            clearCanvas(this.valueCanvas);
            const ctx = this.valueCanvas.getContext('2d');
            const centerX = this.valueCanvas.width / 2;
            const centerY = this.valueCanvas.height / 2;
            if (ctx) {
                const { r, g, b } = hsv(0, 0, this.props.value).rgb();
                ctx.beginPath();
                ctx.arc(centerX, centerY, this.radius, 0, 2 * Math.PI, false);
                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fill();
                ctx.lineWidth = 3;
                ctx.strokeStyle = '#ffffff';
                ctx.stroke();
            }
        };
        this.drawCompositeCanvas = () => {
            clearCanvas(this.compositeCanvas);
            const ctx = this.compositeCanvas.getContext('2d');
            if (ctx) {
                ctx.globalCompositeOperation = 'multiply';
                ctx.drawImage(this.colorWheelCanvas, 0, 0);
                ctx.drawImage(this.valueCanvas, 0, 0);
            }
        };
    }
    componentDidMount() {
        this.drawWheel();
        this.drawValueLayer();
        this.drawCompositeCanvas();
        this.drawMouseMarker();
    }
    componentDidUpdate() {
        this.drawValueLayer();
        this.drawCompositeCanvas();
        this.drawMouseMarker();
    }
    render() {
        return (React.createElement(ColorWheelWrapper, { size: this.props.size },
            React.createElement(Canvas, { ref: this.setColorWheelCanvasRef, width: this.props.size, height: this.props.size }),
            React.createElement(Canvas, { ref: this.setValueCanvasRef, width: this.props.size, height: this.props.size }),
            React.createElement(Canvas, { ref: this.setCompositeCanvasRef, width: this.props.size, height: this.props.size }),
            React.createElement(Canvas, { "data-testid": "mouse-marker", ref: this.setMarkerCanvasRef, width: this.props.size, height: this.props.size, onMouseDown: this.mouseDown, onMouseMove: this.mouseMove, onMouseUp: this.setMouseDragging.bind(this, false), onMouseLeave: this.setMouseDragging.bind(this, false) })));
    }
    get radius() {
        return this.colorWheelCanvas
            ? canvasRadius(this.colorWheelCanvas, canvasMargin)
            : 0;
    }
    drawWheel() {
        const ctx = this.colorWheelCanvas.getContext('2d');
        if (!ctx)
            return;
        const image = this.getColorWheelImage();
        if (image) {
            ctx.putImageData(image, canvasMargin, canvasMargin);
        }
        ctx.beginPath();
        ctx.arc(this.colorWheelCanvas.width / 2, this.colorWheelCanvas.width / 2, this.radius, 0, 2 * Math.PI, false);
        ctx.lineWidth = 3;
        ctx.strokeStyle = '#ffffff';
        ctx.stroke();
    }
    getColorWheelImage() {
        const ctx = this.colorWheelCanvas.getContext('2d');
        if (!this.colorWheelImage && ctx) {
            const colorValue = 1;
            this.colorWheelImage = ctx.createImageData(diameter(this.radius), diameter(this.radius));
            drawColorWheelIntoCanvasImage(this.colorWheelImage.data, generateColorWheel(this.radius, colorValue));
        }
        return this.colorWheelImage;
    }
    drawMouseMarker() {
        clearCanvas(this.markerCanvas);
        const canvasCartesian = hsv2cartesian(this.radius, {
            h: this.props.hue,
            s: this.props.saturation,
            v: this.props.value,
        });
        const mousePosition = translateDiagonal(canvasMargin, canvasCartesian);
        const ctx = this.markerCanvas.getContext('2d');
        if (ctx && mousePosition) {
            const mouseRadius = 4;
            ctx.beginPath();
            ctx.arc(mousePosition.x, mousePosition.y, mouseRadius, 0, 2 * Math.PI, false);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#FFFFFF';
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(mousePosition.x, mousePosition.y, mouseRadius - 1, 0, 2 * Math.PI, false);
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000000';
            ctx.stroke();
        }
    }
    updateColor(position, callback) {
        if (callback && position) {
            const color = cartesian2hsv(this.props.value, this.radius, position);
            const updateColorValues = { h: color.h, s: color.s };
            callback(updateColorValues);
        }
    }
}
ColorWheel.defaultProps = {
    hue: 0,
    saturation: 1,
    size: 100,
    value: 1,
};
const ColorWheelWrapper = styled.div.withConfig({ displayName: "ColorWheelWrapper", componentId: "sc-a42q5" }) `
  position: relative;
  width: ${({ size }) => size}px;
  height: ${({ size }) => size}px;
`;
const Canvas = styled.canvas.withConfig({ displayName: "Canvas", componentId: "sc-xapbr" }) `
  position: absolute;
  left: 0;
  top: 0;
`;
//# sourceMappingURL=ColorWheel.js.map