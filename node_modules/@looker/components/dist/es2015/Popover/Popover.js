var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useEffect, useRef, useState, } from 'react';
import { Popper } from 'react-popper';
import { Box } from '../Layout';
import { ModalContext } from '../Modal';
import { ModalPortal } from '../Modal/ModalPortal';
import { OverlaySurface } from '../Overlay/OverlaySurface';
import { useControlWarn, useFocusTrap } from '../utils';
function useVerticalSpace(ref, pin, placement, isOpen) {
    const [verticalSpace, setVerticalSpace] = useState(0);
    useEffect(() => {
        function getVerticalSpace() {
            if (ref.current) {
                if (pin) {
                    const { top, bottom } = ref.current.getBoundingClientRect();
                    if (placement.indexOf('top') > -1) {
                        setVerticalSpace(top);
                    }
                    else if (placement.indexOf('bottom') > -1) {
                        setVerticalSpace(window.innerHeight - bottom);
                    }
                }
            }
        }
        if (isOpen) {
            window.addEventListener('resize', getVerticalSpace);
            getVerticalSpace();
        }
        return () => {
            window.removeEventListener('resize', getVerticalSpace);
        };
    }, [ref, pin, placement, isOpen]);
    return verticalSpace;
}
function useOpenWithoutElement(isOpen, ref) {
    const [openWithoutElem, setOpenWithoutElem] = useState(isOpen && ref.current === null);
    useEffect(() => {
        if (ref.current && openWithoutElem) {
            setOpenWithoutElem(false);
        }
    }, [openWithoutElem, ref]);
    return openWithoutElem;
}
function usePopoverToggle({ isOpen: controlledIsOpen = false, setOpen: controlledSetOpen, canClose, groupedPopoversRef, }, portalRef, triggerRef) {
    const [uncontrolledIsOpen, uncontrolledSetOpen] = useState(controlledIsOpen);
    const isControlled = useControlWarn({
        controllingProps: ['controlledSetOpen'],
        isControlledCheck: () => controlledSetOpen !== undefined,
        name: 'usePopover',
    });
    const isOpen = isControlled ? controlledIsOpen : uncontrolledIsOpen;
    const setOpen = isControlled && controlledSetOpen ? controlledSetOpen : uncontrolledSetOpen;
    useEffect(() => {
        function handleClickOutside(event) {
            if (canClose && !canClose())
                return;
            if (portalRef.current &&
                portalRef.current.contains(event.target)) {
                return;
            }
            if (portalRef.current &&
                event.target &&
                portalRef.current.compareDocumentPosition(event.target) ===
                    Node.DOCUMENT_POSITION_FOLLOWING) {
                return;
            }
            setOpen(false);
            if (triggerRef.current &&
                triggerRef.current.contains(event.target)) {
                event.stopPropagation();
                return;
            }
            if (groupedPopoversRef &&
                groupedPopoversRef.current &&
                groupedPopoversRef.current.contains(event.target)) {
                return;
            }
            event.stopPropagation();
        }
        if (isOpen) {
            document.addEventListener('click', handleClickOutside, true);
        }
        else {
            document.removeEventListener('click', handleClickOutside, true);
        }
        return () => {
            document.removeEventListener('click', handleClickOutside, true);
        };
    }, [canClose, groupedPopoversRef, isOpen, setOpen, triggerRef, portalRef]);
    return [isOpen, setOpen];
}
export function usePopover(_a) {
    var { arrow = true, canClose, content, groupedPopoversRef, pin = false, isOpen: controlledIsOpen = false, onClose, placement: propsPlacement = 'bottom', hoverDisclosureRef, setOpen: controlledSetOpen } = _a, props = __rest(_a, ["arrow", "canClose", "content", "groupedPopoversRef", "pin", "isOpen", "onClose", "placement", "hoverDisclosureRef", "setOpen"]);
    const portalRef = useRef(null);
    const newTriggerRef = useRef(null);
    const focusRef = useFocusTrap();
    const triggerRef = props.triggerRef || newTriggerRef;
    const [isOpen, setOpen] = usePopoverToggle({
        canClose,
        groupedPopoversRef,
        isOpen: controlledIsOpen,
        setOpen: controlledSetOpen,
    }, portalRef, triggerRef);
    const verticalSpace = useVerticalSpace(triggerRef, pin, propsPlacement, isOpen);
    const openWithoutElem = useOpenWithoutElement(isOpen, triggerRef);
    function handleOpen(event) {
        setOpen(true);
        event.stopPropagation();
        event.preventDefault();
    }
    function handleClose() {
        if (canClose && !canClose())
            return;
        setOpen(false);
        onClose && onClose();
    }
    const [isHovered, setIsHovered] = useState(hoverDisclosureRef === undefined);
    function handleMouseEnter() {
        setIsHovered(true);
    }
    function handleMouseLeave() {
        setIsHovered(false);
    }
    useEffect(() => {
        const refCurrent = hoverDisclosureRef
            ? hoverDisclosureRef.current
            : undefined;
        if (refCurrent) {
            refCurrent.addEventListener('mouseleave', handleMouseLeave);
            refCurrent.addEventListener('mouseenter', handleMouseEnter);
        }
        return () => {
            if (refCurrent) {
                refCurrent.removeEventListener('mouseleave', handleMouseLeave);
                refCurrent.removeEventListener('mouseenter', handleMouseEnter);
            }
        };
    }, [hoverDisclosureRef]);
    const referenceElement = triggerRef && triggerRef.current ? triggerRef.current : undefined;
    const popover = !openWithoutElem && isOpen && (React.createElement(ModalContext.Provider, { value: { closeModal: handleClose } },
        React.createElement(ModalPortal, { portalRef: portalRef },
            React.createElement(Popper, { positionFixed: true, placement: propsPlacement, innerRef: focusRef, modifiers: {
                    flip: {
                        behavior: 'flip',
                        enabled: !pin,
                        flipVariations: true,
                        flipVariationsByContent: true,
                    },
                    preventOverflow: {
                        escapeWithReference: verticalSpace > 50,
                        padding: 0,
                    },
                }, referenceElement: referenceElement }, ({ ref, style, arrowProps, placement }) => (React.createElement(OverlaySurface, { arrow: arrow, arrowProps: arrowProps, placement: placement, ref: ref, style: style, backgroundColor: "palette.white", border: "1px solid", borderColor: "palette.charcoal200", borderRadius: "medium", boxShadow: 3, color: "palette.charcoal900" }, verticalSpace > 50 ? (React.createElement(Box, { maxHeight: `calc(${verticalSpace - 10}px - 1rem)`, overflowY: "scroll" }, content)) : (content)))))));
    return {
        className: isOpen ? 'active' : undefined,
        open: handleOpen,
        popover,
        ref: triggerRef,
        triggerShown: isOpen || isHovered,
    };
}
export function Popover(_a) {
    var { children } = _a, props = __rest(_a, ["children"]);
    const { popover, open, ref, className, triggerShown } = usePopover(props);
    const childrenOutput = children(open, ref, className);
    return (React.createElement(React.Fragment, null,
        popover,
        triggerShown && childrenOutput));
}
//# sourceMappingURL=Popover.js.map