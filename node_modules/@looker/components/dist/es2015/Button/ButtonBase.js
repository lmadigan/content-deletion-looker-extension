var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { radii, reset, space, } from '@looker/design-tokens';
import { rgba } from 'polished';
import React, { forwardRef, useState } from 'react';
import styled, { css } from 'styled-components';
import { minWidth, maxWidth, width, } from 'styled-system';
import { buttonSize } from './size';
import { ButtonIcon, buttonIcon } from './icon';
export const CustomizableButtonAttributes = {
    borderRadius: 'medium',
};
export const buttonCSS = css `
  ${reset}
  ${maxWidth}
  ${minWidth}
  ${width}

  ${props => props.focusVisible &&
    `
    box-shadow: 0 0 0 0.15rem
      ${rgba(props.theme.colors.semanticColors[props.color || 'primary'].main, 0.25)};
  `}

  align-items: center;
  border-radius: ${radii[CustomizableButtonAttributes.borderRadius]};
  cursor: pointer;
  display: inline-flex;
  font-weight: 600;
  justify-content: center;
  outline: none;
  transition: border 80ms;
  vertical-align: middle;
  white-space: nowrap;

  &[disabled] {
    cursor: default;
    filter: grayscale(0.3);
    opacity: 0.25;
  }

  ${buttonSize}
  ${space}
`;
const ButtonOuter = styled.button.withConfig({ displayName: "ButtonOuter", componentId: "sc-wugisi" }) `
  ${buttonCSS}
`;
const ButtonJSX = forwardRef((props, ref) => {
    const { children, iconBefore, iconAfter, onBlur, onKeyDown } = props, restProps = __rest(props, ["children", "iconBefore", "iconAfter", "onBlur", "onKeyDown"]);
    const [isFocusVisible, setFocusVisible] = useState(false);
    const handleOnKeyUp = (event) => {
        setFocusVisible(true);
        onKeyDown && onKeyDown(event);
    };
    const handleOnBlur = (event) => {
        setFocusVisible(false);
        onBlur && onBlur(event);
    };
    return (React.createElement(ButtonOuter, Object.assign({ focusVisible: isFocusVisible, onKeyUp: handleOnKeyUp, onBlur: handleOnBlur }, restProps, { ref: ref }),
        iconBefore && React.createElement(ButtonIcon, { name: iconBefore }),
        children,
        iconAfter && React.createElement(ButtonIcon, { name: iconAfter })));
});
ButtonJSX.displayName = 'ButtonJSX';
export const ButtonBase = styled(ButtonJSX).withConfig({ displayName: "ButtonBase", componentId: "sc-18wmtoc" }) `
  ${buttonIcon}
`;
ButtonBase.defaultProps = { size: 'medium' };
//# sourceMappingURL=ButtonBase.js.map