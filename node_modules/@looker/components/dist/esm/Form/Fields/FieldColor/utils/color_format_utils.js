import * as d3color from 'd3-color';
import * as d3hsv from 'd3-hsv';
import { toPercent } from './math_utils';
import { namedColors } from './named_colors';
export var ColorFormat;
(function (ColorFormat) {
    ColorFormat[ColorFormat["NAME"] = 0] = "NAME";
    ColorFormat[ColorFormat["HEX3"] = 1] = "HEX3";
    ColorFormat[ColorFormat["HEX6"] = 2] = "HEX6";
    ColorFormat[ColorFormat["RGBI"] = 3] = "RGBI";
    ColorFormat[ColorFormat["RGBIA"] = 4] = "RGBIA";
    ColorFormat[ColorFormat["RGBP"] = 5] = "RGBP";
    ColorFormat[ColorFormat["RGBPA"] = 6] = "RGBPA";
    ColorFormat[ColorFormat["HSL"] = 7] = "HSL";
    ColorFormat[ColorFormat["HSLA"] = 8] = "HSLA";
    ColorFormat[ColorFormat["TRANSPARENT"] = 9] = "TRANSPARENT";
    ColorFormat[ColorFormat["BAD"] = 10] = "BAD";
})(ColorFormat || (ColorFormat = {}));
var RGB_MAX_VALUE = 255;
var recognize = function (format) {
    var reI = '\\s*([+-]?\\d+)\\s*';
    var reN = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*';
    var reP = '\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*';
    var reHex3 = /^#([0-9a-f]{3})$/;
    var reHex6 = /^#([0-9a-f]{6})$/;
    var reRgbInteger = new RegExp('^rgb\\(' + [reI, reI, reI] + '\\)$');
    var reRgbPercent = new RegExp('^rgb\\(' + [reP, reP, reP] + '\\)$');
    var reRgbaInteger = new RegExp('^rgba\\(' + [reI, reI, reI, reN] + '\\)$');
    var reRgbaPercent = new RegExp('^rgba\\(' + [reP, reP, reP, reN] + '\\)$');
    var reRgbaPercent2 = new RegExp('^rgba\\(' + [reP, reP, reP, reP] + '\\)$');
    var reHslPercent = new RegExp('^hsl\\(' + [reN, reP, reP] + '\\)$');
    var reHslaPercent = new RegExp('^hsla\\(' + [reN, reP, reP, reN] + '\\)$');
    format = String(format)
        .trim()
        .toLowerCase();
    return reHex3.exec(format)
        ? ColorFormat.HEX3
        : reHex6.exec(format)
            ? ColorFormat.HEX6
            : reRgbInteger.exec(format)
                ? ColorFormat.RGBI
                : reRgbPercent.exec(format)
                    ? ColorFormat.RGBP
                    : reRgbaInteger.exec(format)
                        ? ColorFormat.RGBIA
                        : reRgbaPercent.exec(format)
                            ? ColorFormat.RGBPA
                            : reRgbaPercent2.exec(format)
                                ? ColorFormat.RGBPA
                                : reHslPercent.exec(format)
                                    ? ColorFormat.HSL
                                    : reHslaPercent.exec(format)
                                        ? ColorFormat.HSLA
                                        : Object.prototype.hasOwnProperty.call(namedColors, format)
                                            ? ColorFormat.NAME
                                            : format === 'transparent'
                                                ? ColorFormat.TRANSPARENT
                                                : ColorFormat.BAD;
};
export var getFormat = function (value) { return ColorFormat[recognize(value)]; };
export var getOpacity = function (color) {
    if (color instanceof d3color.cubehelix ||
        color instanceof d3color.hcl ||
        color instanceof d3color.hsl ||
        color instanceof d3color.rgb ||
        color instanceof d3color.lab) {
        return color.opacity;
    }
    return 1;
};
var namedColorLookup = function (color) {
    var hex = color.hex().replace(/^#/, '');
    var lookup = parseInt(hex, 16);
    var namedColorsFlipped = new Map(Object.entries(namedColors).map(function (_a) {
        var k = _a[0], v = _a[1];
        return [v, k];
    }));
    return namedColorsFlipped.get(lookup);
};
export var toColorName = function (color, opacity) {
    if (opacity === void 0) { opacity = null; }
    var opacityUse = opacity || getOpacity(color);
    var name = namedColorLookup(color);
    if (name)
        return name;
    if (opacityUse !== 1)
        return d3color.rgb(color).toString();
    return color.hex();
};
export var toRGBIString = function (color, opacity, useAlpha) {
    if (opacity === void 0) { opacity = null; }
    if (useAlpha === void 0) { useAlpha = false; }
    var opacityUse = opacity || getOpacity(color);
    var rgb = color.rgb();
    var r = Math.round(rgb.r);
    var g = Math.round(rgb.g);
    var b = Math.round(rgb.b);
    if (useAlpha || opacityUse !== 1) {
        return "rgba(" + r + ", " + g + ", " + b + ", " + opacityUse + ")";
    }
    return "rgb(" + r + ", " + g + ", " + b + ")";
};
export var toRGBPString = function (color, opacity, useAlpha) {
    if (opacity === void 0) { opacity = null; }
    if (useAlpha === void 0) { useAlpha = false; }
    var opacityUse = opacity || getOpacity(color);
    var rgb = color.rgb();
    var r = toPercent(rgb.r, RGB_MAX_VALUE);
    var g = toPercent(rgb.g, RGB_MAX_VALUE);
    var b = toPercent(rgb.b, RGB_MAX_VALUE);
    if (useAlpha || opacityUse !== 1) {
        return "rgba(" + r + "%, " + g + "%, " + b + "%, " + opacityUse + ")";
    }
    return "rgb(" + r + "%, " + g + "%, " + b + "%)";
};
export var toHSLString = function (color, opacity, useAlpha) {
    if (opacity === void 0) { opacity = null; }
    if (useAlpha === void 0) { useAlpha = false; }
    var opacityUse = opacity || getOpacity(color);
    var hsl = d3color.hsl(color);
    var h = isNaN(hsl.h) ? 0 : hsl.h;
    var s = isNaN(hsl.s) ? 0 : Math.round(hsl.s * 100);
    var l = isNaN(hsl.l) ? 100 : Math.round(hsl.l * 100);
    if (useAlpha || opacityUse !== 1) {
        return "hsla(" + h + ", " + s + "%, " + l + "%, " + opacityUse + ")";
    }
    return "hsl(" + h + ", " + s + "%, " + l + "%)";
};
export var toFormattedColorString = function (value, format) {
    if (format === void 0) { format = null; }
    var color = d3color.color(value);
    if (!color)
        return '';
    if (!color.displayable)
        return '';
    if (format === null)
        format = recognize(value);
    var opacity = getOpacity(color);
    switch (format) {
        case ColorFormat.NAME:
        case ColorFormat.TRANSPARENT:
            return toColorName(color);
        case ColorFormat.HEX3:
        case ColorFormat.HEX6:
            if (opacity === 1)
                return color.hex();
            return color.rgb().toString();
        case ColorFormat.RGBI:
            return color.rgb().toString();
        case ColorFormat.RGBIA:
            return toRGBIString(color, opacity, true);
        case ColorFormat.RGBP:
            return toRGBPString(color, opacity);
        case ColorFormat.RGBPA:
            return toRGBPString(color, opacity, true);
        case ColorFormat.HSL:
            return toHSLString(color, opacity);
        case ColorFormat.HSLA:
            return toHSLString(color, opacity, true);
        default:
            return color.toString();
    }
};
export var toHSV = function (value) {
    var color = d3color.color(value);
    if (!color)
        return null;
    return d3hsv.hsv(color);
};
export var hsvToColorString = function (hsvColor, format) {
    if (format === void 0) { format = null; }
    return toFormattedColorString(hsvColor.rgb().toString(), format);
};
export var hsv2hex = function (color) {
    return d3hsv.hsv(color.h, color.s, color.v).hex();
};
export var str2simpleHsv = function (color) {
    var hsvColor = d3hsv.hsv(color);
    var simpleHSV = { h: hsvColor.h, s: hsvColor.s, v: hsvColor.v };
    return simpleHSV;
};
export var simpleHSVtoRGB = function (color) {
    return d3hsv.hsv(color.h, color.s, color.v).rgb();
};
export var simpleHSVtoFormattedColorString = function (color, colorFormat) {
    var rgbColor = simpleHSVtoRGB(color);
    switch (colorFormat) {
        case 'NAME':
            return toColorName(rgbColor);
        case 'RGBI':
        case 'RGBIA':
            return toRGBIString(rgbColor);
        case 'RGBP':
        case 'RGBPA':
            return toRGBPString(rgbColor);
        case 'HSL':
        case 'HSLA':
            return toHSLString(rgbColor);
        case 'HEX3':
        case 'HEX6':
        default:
            return rgbColor.hex();
    }
};
//# sourceMappingURL=color_format_utils.js.map