var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { useEffect, useRef, useState, } from 'react';
import { Popper } from 'react-popper';
import { Box } from '../Layout';
import { ModalContext } from '../Modal';
import { ModalPortal } from '../Modal/ModalPortal';
import { OverlaySurface } from '../Overlay/OverlaySurface';
import { useControlWarn, useFocusTrap } from '../utils';
function useVerticalSpace(ref, pin, placement, isOpen) {
    var _a = useState(0), verticalSpace = _a[0], setVerticalSpace = _a[1];
    useEffect(function () {
        function getVerticalSpace() {
            if (ref.current) {
                if (pin) {
                    var _a = ref.current.getBoundingClientRect(), top_1 = _a.top, bottom = _a.bottom;
                    if (placement.indexOf('top') > -1) {
                        setVerticalSpace(top_1);
                    }
                    else if (placement.indexOf('bottom') > -1) {
                        setVerticalSpace(window.innerHeight - bottom);
                    }
                }
            }
        }
        if (isOpen) {
            window.addEventListener('resize', getVerticalSpace);
            getVerticalSpace();
        }
        return function () {
            window.removeEventListener('resize', getVerticalSpace);
        };
    }, [ref, pin, placement, isOpen]);
    return verticalSpace;
}
function useOpenWithoutElement(isOpen, ref) {
    var _a = useState(isOpen && ref.current === null), openWithoutElem = _a[0], setOpenWithoutElem = _a[1];
    useEffect(function () {
        if (ref.current && openWithoutElem) {
            setOpenWithoutElem(false);
        }
    }, [openWithoutElem, ref]);
    return openWithoutElem;
}
function usePopoverToggle(_a, portalRef, triggerRef) {
    var _b = _a.isOpen, controlledIsOpen = _b === void 0 ? false : _b, controlledSetOpen = _a.setOpen, canClose = _a.canClose, groupedPopoversRef = _a.groupedPopoversRef;
    var _c = useState(controlledIsOpen), uncontrolledIsOpen = _c[0], uncontrolledSetOpen = _c[1];
    var isControlled = useControlWarn({
        controllingProps: ['controlledSetOpen'],
        isControlledCheck: function () { return controlledSetOpen !== undefined; },
        name: 'usePopover',
    });
    var isOpen = isControlled ? controlledIsOpen : uncontrolledIsOpen;
    var setOpen = isControlled && controlledSetOpen ? controlledSetOpen : uncontrolledSetOpen;
    useEffect(function () {
        function handleClickOutside(event) {
            if (canClose && !canClose())
                return;
            if (portalRef.current &&
                portalRef.current.contains(event.target)) {
                return;
            }
            if (portalRef.current &&
                event.target &&
                portalRef.current.compareDocumentPosition(event.target) ===
                    Node.DOCUMENT_POSITION_FOLLOWING) {
                return;
            }
            setOpen(false);
            if (triggerRef.current &&
                triggerRef.current.contains(event.target)) {
                event.stopPropagation();
                return;
            }
            if (groupedPopoversRef &&
                groupedPopoversRef.current &&
                groupedPopoversRef.current.contains(event.target)) {
                return;
            }
            event.stopPropagation();
        }
        if (isOpen) {
            document.addEventListener('click', handleClickOutside, true);
        }
        else {
            document.removeEventListener('click', handleClickOutside, true);
        }
        return function () {
            document.removeEventListener('click', handleClickOutside, true);
        };
    }, [canClose, groupedPopoversRef, isOpen, setOpen, triggerRef, portalRef]);
    return [isOpen, setOpen];
}
export function usePopover(_a) {
    var _b = _a.arrow, arrow = _b === void 0 ? true : _b, canClose = _a.canClose, content = _a.content, groupedPopoversRef = _a.groupedPopoversRef, _c = _a.pin, pin = _c === void 0 ? false : _c, _d = _a.isOpen, controlledIsOpen = _d === void 0 ? false : _d, onClose = _a.onClose, _e = _a.placement, propsPlacement = _e === void 0 ? 'bottom' : _e, hoverDisclosureRef = _a.hoverDisclosureRef, controlledSetOpen = _a.setOpen, props = __rest(_a, ["arrow", "canClose", "content", "groupedPopoversRef", "pin", "isOpen", "onClose", "placement", "hoverDisclosureRef", "setOpen"]);
    var portalRef = useRef(null);
    var newTriggerRef = useRef(null);
    var focusRef = useFocusTrap();
    var triggerRef = props.triggerRef || newTriggerRef;
    var _f = usePopoverToggle({
        canClose: canClose,
        groupedPopoversRef: groupedPopoversRef,
        isOpen: controlledIsOpen,
        setOpen: controlledSetOpen,
    }, portalRef, triggerRef), isOpen = _f[0], setOpen = _f[1];
    var verticalSpace = useVerticalSpace(triggerRef, pin, propsPlacement, isOpen);
    var openWithoutElem = useOpenWithoutElement(isOpen, triggerRef);
    function handleOpen(event) {
        setOpen(true);
        event.stopPropagation();
        event.preventDefault();
    }
    function handleClose() {
        if (canClose && !canClose())
            return;
        setOpen(false);
        onClose && onClose();
    }
    var _g = useState(hoverDisclosureRef === undefined), isHovered = _g[0], setIsHovered = _g[1];
    function handleMouseEnter() {
        setIsHovered(true);
    }
    function handleMouseLeave() {
        setIsHovered(false);
    }
    useEffect(function () {
        var refCurrent = hoverDisclosureRef
            ? hoverDisclosureRef.current
            : undefined;
        if (refCurrent) {
            refCurrent.addEventListener('mouseleave', handleMouseLeave);
            refCurrent.addEventListener('mouseenter', handleMouseEnter);
        }
        return function () {
            if (refCurrent) {
                refCurrent.removeEventListener('mouseleave', handleMouseLeave);
                refCurrent.removeEventListener('mouseenter', handleMouseEnter);
            }
        };
    }, [hoverDisclosureRef]);
    var referenceElement = triggerRef && triggerRef.current ? triggerRef.current : undefined;
    var popover = !openWithoutElem && isOpen && (React.createElement(ModalContext.Provider, { value: { closeModal: handleClose } },
        React.createElement(ModalPortal, { portalRef: portalRef },
            React.createElement(Popper, { positionFixed: true, placement: propsPlacement, innerRef: focusRef, modifiers: {
                    flip: {
                        behavior: 'flip',
                        enabled: !pin,
                        flipVariations: true,
                        flipVariationsByContent: true,
                    },
                    preventOverflow: {
                        escapeWithReference: verticalSpace > 50,
                        padding: 0,
                    },
                }, referenceElement: referenceElement }, function (_a) {
                var ref = _a.ref, style = _a.style, arrowProps = _a.arrowProps, placement = _a.placement;
                return (React.createElement(OverlaySurface, { arrow: arrow, arrowProps: arrowProps, placement: placement, ref: ref, style: style, backgroundColor: "palette.white", border: "1px solid", borderColor: "palette.charcoal200", borderRadius: "medium", boxShadow: 3, color: "palette.charcoal900" }, verticalSpace > 50 ? (React.createElement(Box, { maxHeight: "calc(" + (verticalSpace - 10) + "px - 1rem)", overflowY: "scroll" }, content)) : (content)));
            }))));
    return {
        className: isOpen ? 'active' : undefined,
        open: handleOpen,
        popover: popover,
        ref: triggerRef,
        triggerShown: isOpen || isHovered,
    };
}
export function Popover(_a) {
    var children = _a.children, props = __rest(_a, ["children"]);
    var _b = usePopover(props), popover = _b.popover, open = _b.open, ref = _b.ref, className = _b.className, triggerShown = _b.triggerShown;
    var childrenOutput = children(open, ref, className);
    return (React.createElement(React.Fragment, null,
        popover,
        triggerShown && childrenOutput));
}
//# sourceMappingURL=Popover.js.map