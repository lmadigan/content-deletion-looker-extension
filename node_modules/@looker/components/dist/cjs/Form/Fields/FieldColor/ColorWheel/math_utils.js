"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cartesian2polar = function (coord) { return ({
    angle: Math.atan2(coord.y, coord.x),
    radius: Math.round(Math.sqrt(coord.x * coord.x + coord.y * coord.y)),
}); };
exports.polar2cartesian = function (coord) { return ({
    x: coord.radius * Math.cos(coord.angle),
    y: coord.radius * Math.sin(coord.angle),
}); };
exports.rad2deg = function (rad) { return (rad / (2 * Math.PI)) * 360; };
exports.deg2rad = function (angle) { return angle * (Math.PI / 180); };
exports.diameter = function (radius) { return 2 * radius; };
exports.translate = function (by, val) { return val + by; };
exports.translateDiagonal = function (by, coordinate) { return ({
    x: exports.translate(by, coordinate.x),
    y: exports.translate(by, coordinate.y),
}); };
exports.scaleRadius = function (by, coord) { return (__assign(__assign({}, coord), { radius: coord.radius * by })); };
exports.limitByRadius = function (coord, radius) {
    var _a = exports.translateDiagonal(-radius, coord), x = _a.x, y = _a.y;
    var distanceFromCenter = Math.min(Math.sqrt(x * x + y * y), radius);
    var angle = Math.atan2(y, x);
    var newCoord = exports.polar2cartesian({ angle: angle, radius: distanceFromCenter });
    return {
        x: newCoord.x + radius,
        y: newCoord.y + radius,
    };
};
//# sourceMappingURL=math_utils.js.map