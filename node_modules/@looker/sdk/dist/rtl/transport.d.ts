/// <reference types="node" />
/** A transport is a generic way to make HTTP requests. */
import { Agent } from 'https';
import { Headers } from 'request';
import { IApiSettings } from './apiSettings';
import { Readable } from "readable-stream";
export declare const agentTag: string;
/**
 * trivial tracing function that should be replaced with a log plugin
 * @param message description for trace
 * @param info any additional information to produce for output
 */
export declare function trace(message: string, info?: any): void;
/**
 * ResponseMode for an HTTP request - either binary or "string"
 */
export declare enum ResponseMode {
    'binary' = 0,
    'string' = 1,
    'unknown' = 2
}
/**
 * MIME patterns for string content types
 * @type {RegExp}
 */
export declare const contentPatternString: RegExp;
/**
 * MIME patterns for "binary" content types
 * @type {RegExp}
 */
export declare const contentPatternBinary: RegExp;
/**
 * MIME pattern for UTF8 charset attribute
 * @type {RegExp}
 */
export declare const charsetUtf8Pattern: RegExp;
/**
 * Default request timeout
 * @type {number} default request timeout is 120 seconds, or two minutes
 */
export declare const defaultTimeout = 120;
/**
 * Recognized HTTP methods
 */
export declare type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'TRACE' | 'HEAD';
/**
 * HTTP status codes
 * https://developer.mozilla.org/en-US/docs/Web/HTTP/Status for reference
 */
export declare enum StatusCode {
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritative = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    MultiStatusDav = 208,
    IMUsed = 226,
    MultipleChoice = 300,
    MovedPermanently = 301,
    Found = 302,
    SeeOther = 303,
    NotModified = 304,
    UseProxy = 305,
    UnusedRedirect = 306,
    TemporaryRedirect = 307,
    PermanentRedirect = 308,
    BadRequest = 400,
    Unauthorized = 401,
    PaymentRequired = 402,
    Forbidden = 403,
    NotFound = 404,
    MethodNotAllowed = 405,
    NotAcceptable = 406,
    ProxyAuthRequired = 407,
    RequestTimeout = 408,
    Conflict = 409,
    Gone = 410,
    LengthRequired = 411,
    PreconditionFailed = 412,
    PayloadTooLarge = 413,
    UriTooLong = 414,
    UnsupportedMediaType = 415,
    RequestedRangeNotSatisfiable = 416,
    ExpectationFailed = 417,
    ImATeapot = 418,
    MisdirectedRequest = 421,
    UnprocessableEntity = 422,
    Locked = 423,
    FailedDependency = 424,
    TooEarly = 425,
    UpgradeRequired = 426,
    PreconditionRequired = 427,
    TooManyRequests = 428,
    RequestHeaderFieldsTooLarge = 429,
    UnavailableForLegalReasons = 430,
    InternalServerError = 500,
    NotImplemented = 501,
    BadGateway = 502,
    ServiceUnavailable = 503,
    GatewayTimeout = 504,
    HttpVersionNotSupported = 505,
    VariantAlsoNegotiates = 506,
    InsufficientStorage = 507,
    LoopDetected = 508,
    NotExtended = 510,
    NetworkAuthRequired = 511
}
export interface ITransport {
    request<TSuccess, TError>(method: HttpMethod, path: string, queryParams?: Values, body?: any, authenticator?: Authenticator, options?: Partial<ITransportSettings>): Promise<SDKResponse<TSuccess, TError>>;
    stream<T>(callback: (readable: Readable) => Promise<T>, method: HttpMethod, path: string, queryParams?: Values, body?: any, authenticator?: Authenticator, options?: Partial<ITransportSettings>): Promise<T>;
}
/** A successful SDK call. */
interface ISDKSuccessResponse<T> {
    /** Whether the SDK call was successful. */
    ok: true;
    /** The object returned by the SDK call. */
    value: T;
}
/** An erroring SDK call. */
interface ISDKErrorResponse<T> {
    /** Whether the SDK call was successful. */
    ok: false;
    /** The error object returned by the SDK call. */
    error: T;
}
/** An error representing an issue in the SDK, like a network or parsing error. */
export interface ISDKError {
    type: 'sdk_error';
    message: string;
}
export declare type SDKResponse<TSuccess, TError> = ISDKSuccessResponse<TSuccess> | ISDKErrorResponse<TError | ISDKError>;
/**
 * Base authorization interface
 */
export interface IAuthorizer {
    settings: IApiSettings;
    transport: ITransport;
    /** is the current session authenticated? */
    isAuthenticated(): boolean;
    authenticate(init: IRequestInit): Promise<IRequestInit>;
    logout(): Promise<boolean>;
}
/** Generic http request property collection */
export interface IRequestInit {
    /** body of request. optional */
    body?: any;
    /** headers for request. optional */
    headers?: any;
    /** Http method for request. required. */
    method: HttpMethod;
    /** Redirect processing for request. optional */
    redirect?: any;
    /** http.Agent instance, allows custom proxy, certificate etc. */
    agent?: Agent;
    /** support gzip/deflate content encoding. false to disable */
    compress?: boolean;
    /** maximum redirect count. 0 to not follow redirect */
    follow?: number;
    /** maximum response body size in bytes. 0 to disable */
    size?: number;
    /** req/res timeout in ms, it resets on redirect. 0 to disable (OS limit applies) */
    timeout?: number;
}
/** General purpose authentication callback */
export declare type Authenticator = (init: any) => any;
/** Interface for API transport values */
export interface ITransportSettings {
    [key: string]: any;
    /** base URL of host address */
    base_url: string;
    /** api version */
    api_version: string;
    /** standard headers to provide in all transport requests */
    headers?: Headers;
    /** whether to verify ssl certs or not. Defaults to true */
    verify_ssl: boolean;
    /** request timeout in seconds. Default to 30 */
    timeout: number;
    /** encoding override */
    encoding?: string | null;
}
/**
 * Is the content type binary or "string"?
 * @param {string} contentType
 * @returns {ResponseMode.binary | ResponseMode.string}
 */
export declare function responseMode(contentType: string): ResponseMode;
/**
 * Does this content type have a UTF-8 charset?
 * @param contentType
 * @returns match if it exists
 */
export declare function isUtf8(contentType: string): RegExpMatchArray | null;
/**
 * Used for name/value pair collections like for QueryParams
 */
export declare type Values = {
    [key: string]: any;
} | null | undefined;
/**
 * Converts `Values` to query string parameter format
 * @param values Name/value collection to encode
 * @returns {string} query string parameter formatted values. Both `false` and `null` are included. Only `undefined` are omitted.
 */
export declare function encodeParams(values?: Values): string;
/**
 * constructs the path argument including any optional query parameters
 * @param path the base path of the request
 * @param obj optional collection of query parameters to encode and append to the path
 */
export declare function addQueryParams(path: string, obj?: Values): string;
/**
 * SDK error handler
 * @param result any kind of error
 * @returns a new `Error` object with the failure message
 */
export declare function sdkError(result: any): Error;
export {};
